"""
Python script to generate penny-shaped cracks within a 40 X 40 X 19 mm steel block
There are four parameters:
 - Short axis
 - Long axis (size)
 - Location (depth)
 - Orientation

There are in total three output files generated by this python script
1 - Ellip_crack.csv contains simulation data in a time-amplitude form
2 - Ellip_crack_info.csv contains all the crack info that correspond to the above simulation
3 - Ellip_failed_simulation.txt contains information about all the failed simulations

Written by Sijun Niu, November 10th 2020
"""
############################################################################################################
# -*- coding: mbcs -*-

"""Import modules"""
from part import *
from material import *
from section import *
from assembly import *
from step import *
from interaction import *
from load import *
from mesh import *
from optimization import *
from job import *
from sketch import *
from visualization import *
from connectorBehavior import *
from odbAccess import *
import sys
import os
import random
import math
import xlsxwriter
import time

"""This command uses findAt functions to locate objects such as faces and cells, instead of getSequencyFromMask"""
session.journalOptions.setValues(replayGeometry=COORDINATE, recoverGeometry=COORDINATE)

"""Activate the corresponding properties to be used in the simulation"""
# Set the flag to True to activate
crack_short_axis = False
crack_long_axis = False
crack_depth = False
crack_orientation = False

# Set the flag to True if odb is not needed
remove_odb = True

"""Remove the old files"""
try:
	os.remove('ellip_crack_3D/Ellip_3D.xlsx')
except WindowsError:
	pass
try:
	os.remove('ellip_crack_3D/Ellip_3D_info.xlsx')
except WindowsError:
	pass

"""Create workbooks to store simulation data"""
wb1 = xlsxwriter.Workbook('ellip_crack_3D/Ellip_3D.xlsx')
wb2 = xlsxwriter.Workbook('ellip_crack_3D/Ellip_3D_info.xlsx')
sheet1 = wb1.add_worksheet()
sheet2 = wb2.add_worksheet()

"""Set the parameters of the simulation"""
# Number of simulation
num_of_simulation = 1

# Default geometric parameters
default_short_axis = 0.0003
default_long_axis = 0.002
default_depth = 0.01
default_angle = math.pi / 4

# Range for the parameters if True flag is set
short_axis_min = 0.0002
short_axis_max = 0.0005
long_axis_min = 0.0005
long_axis_max = 0.0025
depth_min = 0.007
depth_max = 0.015
angle_min = 0.0
angle_max = math.pi/2.0 * 0.99

# Possible depth location
possible_depth = [0.007, 0.011, 0.015]

# Partition size for inner box, outer box and probe size
part_in = 0.003
probe_radius = 0.003

# Mesh size near the crack edges
mesh_size_fine = 0.00012

# Ordered mesh size outside the partition for elliptical crack
mesh_size_general = 0.00012

# Coarse mesh far from the elliptical crack
mesh_size_coarse = 0.0008

# Total time and user-fixed time increment
total_time = 8.0e-06
time_increment = 2e-09
sampling_number = total_time / time_increment

# Material parameters of the plate [SI unit]
young_modulus = 180000000000.0
poisson_ratio = 0.312
mat_density = 7300

# The number of evenly spaced data
space_number = 30

"""Lists to be used later"""
# List to store failed simulation info
failed_mesh = []
failed_earlystop = []

# Set default crack information if not otherwise specified in the loop
if crack_short_axis:
	short_axes = [random.uniform(short_axis_min, short_axis_max) for i in range(num_of_simulation)]
else:
	short_axes = [default_short_axis for i in range(num_of_simulation)]

if crack_long_axis:
	long_axes = [random.uniform(long_axis_min, long_axis_max) for i in range(num_of_simulation)]
	#long_axes = [long_axis_min + i * (long_axis_max - long_axis_min) / (space_number - 1) for i in range(space_number)]
else:
	long_axes = [default_long_axis for i in range(num_of_simulation)]

if crack_depth:
	depths = [random.uniform(depth_min, depth_max) for i in range(num_of_simulation)]
	#depths = [possible_depth[random.randint(0,2)] for i in range(num_of_simulation)]
else:
	depths = [default_depth for i in range(num_of_simulation)]

if crack_orientation:
	angles = [random.uniform(angle_min, angle_max) for i in range(num_of_simulation)]
	#angles = [angle_min + i * (angle_max - angle_min) / (space_number - 1) for i in range(space_number)]
else:
	angles = [default_angle for i in range(num_of_simulation)]

"""Initiate the while loop"""
current_index = 1
loop_index = 0
failure_flag = 0
trial_index = 0
max_trial = 0

while current_index <= num_of_simulation:

	if not failure_flag:
		current_short_axis = short_axes[current_index - 1]
		current_long_axis = long_axes[current_index - 1]
		current_depth = depths[current_index - 1]
		current_angle = angles[current_index - 1]

		"""To create even spaced data"""
		#current_long_axis = long_axes[loop_index]
		#current_angle = angles[(current_index - 1) % space_number]

	else:
		trial_index = trial_index + 1
		current_short_axis = short_axes[current_index - 1]
		current_long_axis = long_axes[loop_index] - crack_long_axis * trial_index * 0.01 * long_axes[loop_index]
		current_depth = depths[current_index - 1]
		current_angle = angles[(current_index - 1) % space_number] - crack_orientation * trial_index * 0.01 * angles[(current_index - 1) % space_number]

	## Create 3D part
	mdb.models['Model-1'].ConstrainedSketch(name='__profile__', sheetSize=0.5)
	mdb.models['Model-1'].sketches['__profile__'].rectangle(point1=(0.0, 0.0),point2=(0.04, 0.02))
	mdb.models['Model-1'].Part(dimensionality=THREE_D, name='pipe', type=DEFORMABLE_BODY)
	mdb.models['Model-1'].parts['pipe'].BaseSolidExtrude(depth=0.019, sketch=
		mdb.models['Model-1'].sketches['__profile__'])
	del mdb.models['Model-1'].sketches['__profile__']

	## Define PART cell, surfaces and edges for reference
	part_top_face = mdb.models['Model-1'].parts['pipe'].faces.findAt((0.013333, 0.006667, 0.019), )
	part_front_face = mdb.models['Model-1'].parts['pipe'].faces.findAt((0.01, 0.0, 0.01), )
	part_top_right_edge = mdb.models['Model-1'].parts['pipe'].edges.findAt((0.04, 0.015, 0.019), )
	part_front_right_edge = mdb.models['Model-1'].parts['pipe'].edges.findAt((0.04, 0.0, 0.015), )
	part_whole_cell = mdb.models['Model-1'].parts['pipe'].cells.findAt(((0.019022, 0.000405, 0.019), ))

	## Define Datum points and axes globally
	mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth))
	mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth + part_in))
	mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth - part_in))
	mdb.models['Model-1'].parts['pipe'].DatumPointByCoordinate(coords=(0.0, 0.0, 0.019 - current_depth))
	mdb.models['Model-1'].parts['pipe'].DatumAxisByPrincipalAxis(principalAxis=XAXIS)
	mdb.models['Model-1'].parts['pipe'].DatumAxisByPrincipalAxis(principalAxis=YAXIS)
	mdb.models['Model-1'].parts['pipe'].DatumAxisByPrincipalAxis(principalAxis=ZAXIS)
	datum_y = mdb.models['Model-1'].parts['pipe'].datums[7]
	datum_z = mdb.models['Model-1'].parts['pipe'].datums[8]

	## Partition the body into three regions
	mdb.models['Model-1'].ConstrainedSketch(gridSpacing=0.002, name='__profile__',
		sheetSize=0.097, transform=
		mdb.models['Model-1'].parts['pipe'].MakeSketchTransform(
		sketchPlane=part_top_face, sketchPlaneSide=SIDE1,
		sketchUpEdge=part_top_right_edge, sketchOrientation=RIGHT, origin=(0.02, 0.01, 0.019)))
	mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(
		decimalPlaces=3)
	mdb.models['Model-1'].parts['pipe'].projectReferencesOntoSketch(filter=
		COPLANAR_EDGES, sketch=mdb.models['Model-1'].sketches['__profile__'])
	mdb.models['Model-1'].sketches['__profile__'].ArcByCenterEnds(center=(0.0,
		-0.01), direction=CLOCKWISE, point1=(-probe_radius, -0.01), point2=(probe_radius,
		-0.01))
	mdb.models['Model-1'].sketches['__profile__'].ArcByCenterEnds(center=(0.0,
		-0.01), direction=CLOCKWISE, point1=(-0.014, -0.01), point2=(0.014, -0.01))
	mdb.models['Model-1'].parts['pipe'].PartitionFaceBySketch(faces=part_top_face,
		sketch=mdb.models['Model-1'].sketches['__profile__'], sketchUpEdge=part_top_right_edge)
	del mdb.models['Model-1'].sketches['__profile__']
	mdb.models['Model-1'].parts['pipe'].PartitionCellByExtrudeEdge(cells=part_whole_cell,
		edges=(mdb.models['Model-1'].parts['pipe'].edges.findAt((
		0.010101, 0.009899, 0.019), ), ), line=datum_z, sense=REVERSE)
	mdb.models['Model-1'].parts['pipe'].PartitionCellByExtrudeEdge(cells=
		mdb.models['Model-1'].parts['pipe'].cells.findAt(((0.02, 0.0001, 0.01), )),
		edges=(mdb.models['Model-1'].parts['pipe'].edges.findAt((
		0.02, 0.003, 0.019), ), ), line=datum_z, sense=REVERSE)

	# Revolve cut of the center cell
	mdb.models['Model-1'].ConstrainedSketch(gridSpacing=0.001, name='__profile__',sheetSize=0.044, transform=
		mdb.models['Model-1'].parts['pipe'].MakeSketchTransform(
		sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.021058,0.0,0.012667), ),
		sketchPlaneSide=SIDE1,sketchUpEdge=mdb.models['Model-1'].parts['pipe'].edges.findAt((0.023,0.0,0.01425), ),
		sketchOrientation=RIGHT, origin=(0.02, 0.0, 0.0095)))
	mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(decimalPlaces=3)
	mdb.models['Model-1'].parts['pipe'].projectReferencesOntoSketch(filter=
		COPLANAR_EDGES, sketch=mdb.models['Model-1'].sketches['__profile__'])
	mdb.models['Model-1'].sketches['__profile__'].ConstructionLine(point1=(0.0, 0.0095 - current_depth),
		point2=(-math.tan(current_angle), 0.0095 - current_depth + 1))

	# Save the construction line
	const_line = mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
		(math.tan(current_angle), 0.0095 - current_depth - 1))

	mdb.models['Model-1'].sketches['__profile__'].EllipseByCenterPerimeter(
		axisPoint1=(-current_short_axis * math.sin(current_angle),
		current_short_axis * math.cos(current_angle) + 0.0095 - current_depth),
		axisPoint2=(current_long_axis * math.cos(current_angle),
		current_long_axis * math.sin(current_angle) + 0.0095 - current_depth), center=(0.0, 0.0095 - current_depth))
	mdb.models['Model-1'].sketches['__profile__'].breakCurve(
		curve1=mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
		(current_long_axis * math.cos(current_angle),
		 current_long_axis * math.sin(current_angle) + 0.0095 - current_depth)),
		curve2=const_line,
		point1=(current_long_axis * math.cos(current_angle),
		current_long_axis * math.sin(current_angle) + 0.0095 - current_depth),
		point2=(0.01 * math.tan(current_angle), 0.0095 - current_depth - 0.01))
	mdb.models['Model-1'].sketches['__profile__'].delete(objectList=(
		mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((-current_long_axis * math.cos(current_angle),
		-current_long_axis * math.sin(current_angle) + 0.0095 - current_depth), ),))
	mdb.models['Model-1'].sketches['__profile__'].Line(
		point1=(-current_short_axis * math.sin(current_angle),
		current_short_axis * math.cos(current_angle) + 0.0095 - current_depth),
		point2=(current_short_axis * math.sin(current_angle),
		-current_short_axis * math.cos(current_angle) + 0.0095 - current_depth))
	mdb.models['Model-1'].sketches['__profile__'].PerpendicularConstraint(
		addUndoState=False, entity1=
		mdb.models['Model-1'].sketches['__profile__'].geometry.findAt((0.0, 0.0095 - current_depth), ),
		entity2=mdb.models['Model-1'].sketches['__profile__'].geometry.findAt(
		(current_long_axis * math.cos(current_angle),
		current_long_axis * math.sin(current_angle) + 0.0095 - current_depth), ))
	mdb.models['Model-1'].sketches['__profile__'].sketchOptions.setValues(constructionGeometry=ON)
	mdb.models['Model-1'].sketches['__profile__'].assignCenterline(line=const_line)
	mdb.models['Model-1'].parts['pipe'].CutRevolve(angle=180.0,flipRevolveDirection=OFF, sketch=
		mdb.models['Model-1'].sketches['__profile__'],sketchOrientation=RIGHT,
		sketchPlane=mdb.models['Model-1'].parts['pipe'].faces.findAt((0.02, 0.0, 0.01), ),
		sketchPlaneSide=SIDE1, sketchUpEdge=mdb.models['Model-1'].parts['pipe'].edges.findAt((0.023, 0.0, 0.01),))
	del mdb.models['Model-1'].sketches['__profile__']

	# Create a perpendicular construction line in the PART module
	const_line = mdb.models['Model-1'].parts['pipe'].datums[12]
	mdb.models['Model-1'].parts['pipe'].DatumAxisByRotation(angle=90.0, axis=datum_y, line=const_line)

	## Material properties and instance
	mdb.models['Model-1'].Material(name='steel')
	mdb.models['Model-1'].materials['steel'].Density(table=((mat_density,),))
	mdb.models['Model-1'].materials['steel'].Elastic(table=((young_modulus, poisson_ratio),))
	mdb.models['Model-1'].HomogeneousSolidSection(material='steel', name='Section-1', thickness=None)
	mdb.models['Model-1'].parts['pipe'].SectionAssignment(offset=0.0, offsetField='', offsetType=MIDDLE_SURFACE,
		region=Region(cells=mdb.models['Model-1'].parts['pipe'].cells.findAt(
		((0.030275,0.001038, 0.0),), ((0.013333, 0.02, 0.012667),), ((0.021244, 0.000454,0.011114),), )),
		sectionName='Section-1',thicknessAssignment=FROM_SECTION)
	mdb.models['Model-1'].rootAssembly.DatumCsysByDefault(CARTESIAN)
	if current_index == 1:
		mdb.models['Model-1'].rootAssembly.Instance(dependent=OFF, name='pipe-1',
			part=mdb.models['Model-1'].parts['pipe'])
	else:
		del mdb.models['Model-1'].rootAssembly.instances['pipe-1']
		mdb.models['Model-1'].rootAssembly.Instance(dependent=OFF, name='pipe-1',
			part=mdb.models['Model-1'].parts['pipe'])

	## Save construction line in the global assembly
	const_line = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[12]
	const_line2 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[13]
	datum_pt1 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[2]
	datum_pt2 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[3]
	datum_pt3 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[4]
	datum_pt4 = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[5]
	datum_x = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[6]
	datum_y = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[7]
	datum_z = mdb.models['Model-1'].rootAssembly.instances['pipe-1'].datums[8]

	# Create set for the symmetry plane
	mdb.models['Model-1'].rootAssembly.Set(faces=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(
		((0.001, 0.0, 0.018),), ((0.007, 0.0, 0.018),), ((0.021, 0.0, 0.018),),
		((0.03, 0.0, 0.018),), ((0.038, 0.0, 0.018),),), name='sym_plane')

	# Create surface for the exciter
	mdb.models['Model-1'].rootAssembly.Surface(name='exciter',
		side1Faces=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((0.02, 0.001, 0.019), )))

	# Create set for center region before meshing
	mdb.models['Model-1'].rootAssembly.Set(cells=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((0.02, 0.001, 0.01),),), name='center')

	## Partition middle region cell
	mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.0171, 0.00001, datum_pt2.pointOn[2] + 0.0001),)),normal=datum_z, point=datum_pt2)

	mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.0171, 0.00001, datum_pt3.pointOn[2] - 0.0001),)), normal=datum_z, point=datum_pt3)

	# Partition the top region
	mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.0171, 0.00001, datum_pt2.pointOn[2] + 0.0001),)), normal=datum_x, point=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		(0.02, 0.0, 0.019), ), MIDDLE))

	mdb.models['Model-1'].rootAssembly.PartitionCellByPlanePointNormal(cells=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.0171, 0.00001, datum_pt3.pointOn[2] - 0.0001),)), normal=datum_x, point=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
			(0.02, 0.0, 0.0), ), MIDDLE))

	# Partition the top edge for sensor
	mdb.models['Model-1'].rootAssembly.PartitionEdgeByParam(edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.02, 0.001, 0.019),)),parameter=0.75)

	## Create sensor set
	mdb.models['Model-1'].rootAssembly.Set(edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.02, 0.002, 0.019),),), name='sensor')

	## Create a big test sensor set
	mdb.models['Model-1'].rootAssembly.Set(faces=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((0.021, 0.001, 0.019), ),
		((0.019, 0.001, 0.019), )), name='sensor_all')

	## Assign seeds
	# Global seed
	mdb.models['Model-1'].rootAssembly.seedPartInstance(deviationFactor=0.1,minSizeFactor=0.8, regions=(
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'],), size=mesh_size_general)

	# Single biased seed for connection regions, from 0.0001 to 0.0008
	mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end1Edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.01, 0.0, 0.0),),
		((0.01, 0.0, 0.019),), ), maxSize=mesh_size_coarse, minSize=mesh_size_general)
	mdb.models['Model-1'].rootAssembly.seedEdgeByBias(biasMethod=SINGLE,constraint=FINER, end2Edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(((0.03, 0.0, 0.0),),
		((0.03, 0.0, 0.019),), ), maxSize=mesh_size_coarse, minSize=mesh_size_general)

	# Seed for edges parallel to z axis
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE,deviationFactor=0.5, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.0, 0.0, 0.01),), ((0.006, 0.0, 0.001),), ((0.034, 0.0, 0.01),), ((0.04, 0.0, 0.01),)),
		minSizeFactor=0.1, size=mesh_size_general)

	# Seed for connection region, two semi-circles
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.02, 0.014, 0.0),), ((0.02, 0.014, 0.019),)),
		minSizeFactor=0.1, size=mesh_size_coarse)

	# Seed for out region
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FREE, deviationFactor=0.5, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.001, 0.0, 0.0),), ((0.039, 0.0, 0.0),), ((0.0, 0.01, 0.0),), ((0.04, 0.01, 0.0),), ((0.02, 0.02, 0.0),)),
		minSizeFactor=0.1, size=mesh_size_coarse)

	# Seed the center region, fix the seed number
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FIXED, deviationFactor=0.5, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.019, 0.0, datum_pt2.pointOn[2]),), ((0.021, 0.0, datum_pt2.pointOn[2]),)),
		minSizeFactor=0.8, size=mesh_size_general)

	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FIXED, deviationFactor=0.5, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.019, 0.0, datum_pt3.pointOn[2]),), ((0.021, 0.0, datum_pt3.pointOn[2]),)),
		minSizeFactor=0.8, size=mesh_size_general)

	# Seed the crack perimeter
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.02 + current_long_axis * math.cos(current_angle), 0.0, 0.019 - current_depth + current_long_axis * math.sin(current_angle)),),
		((0.02 - current_long_axis * math.cos(current_angle), 0.0, 0.019 - current_depth - current_long_axis * math.sin(current_angle)),)),
		minSizeFactor=0.8, size=mesh_size_fine)

	# Partition the ellip crack face for better meshing result
	mdb.models['Model-1'].rootAssembly.PartitionFaceByShortestPath(faces=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].faces.findAt(((
		0.02, current_long_axis, 0.019 - current_depth),)), point1=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
		0.02 + current_long_axis * math.cos(current_angle), 0.0, 0.019 - current_depth + current_long_axis * math.sin(current_angle)), ),
		MIDDLE), point2=mdb.models['Model-1'].rootAssembly.instances['pipe-1'].InterestingPoint(
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt((
		0.02 - current_long_axis * math.cos(current_angle), 0.0, 0.019 - current_depth - current_long_axis * math.sin(current_angle)), ), MIDDLE))

	# Seed the crack perimeter
	mdb.models['Model-1'].rootAssembly.seedEdgeBySize(constraint=FINER, deviationFactor=0.8, edges=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].edges.findAt(
		((0.02, current_long_axis, 0.019 - current_depth),)),
		minSizeFactor=0.8, size=mesh_size_fine)

	# Set Tet element type for the crack region
	mdb.models['Model-1'].rootAssembly.setMeshControls(elemShape=TET, regions=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(((0.02,
		0.002, datum_pt2.pointOn[2] - 0.0001),)), sizeGrowthRate=1.2,technique=FREE)

	mdb.models['Model-1'].rootAssembly.setElementType(elemTypes=(ElemType(
		elemCode=UNKNOWN_HEX, elemLibrary=EXPLICIT), ElemType(
		elemCode=UNKNOWN_WEDGE, elemLibrary=EXPLICIT), ElemType(elemCode=C3D10M,
		elemLibrary=EXPLICIT, secondOrderAccuracy=OFF,distortionControl=DEFAULT)),
		regions=(mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.02, 0.002, datum_pt2.pointOn[2] - 0.0001),)),))

	## Mesh
	# Mesh the center region except the crack partition
	mdb.models['Model-1'].rootAssembly.generateMesh(regions=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.0171, 0.00001, datum_pt2.pointOn[2] + 0.001),), ((0.0229, 0.00001, datum_pt2.pointOn[2] + 0.001),),
		((0.0171, 0.00001, datum_pt3.pointOn[2] - 0.001),), ((0.0229, 0.00001, datum_pt3.pointOn[2] - 0.001),)))

	# Mesh the connection region
	mdb.models['Model-1'].rootAssembly.generateMesh(regions=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.01, 0.001, 0.018),)))

	# Mesh the out region
	mdb.models['Model-1'].rootAssembly.generateMesh(regions=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.001, 0.001, 0.018),)))

	# Mesh the crack region
	mdb.models['Model-1'].rootAssembly.generateMesh(regions=
		mdb.models['Model-1'].rootAssembly.instances['pipe-1'].cells.findAt(
		((0.02, 0.002, datum_pt2.pointOn[2] - 0.001),)))

	## Create steps and outputs
	mdb.models['Model-1'].ExplicitDynamicsStep(name='Step-1', nlgeom=OFF, previous='Initial',
		timeIncrementationMethod=FIXED_USER_DEFINED_INC, timePeriod=total_time, userDefinedInc=time_increment)
	mdb.models['Model-1'].fieldOutputRequests['F-Output-1'].suppress()
	mdb.models['Model-1'].historyOutputRequests['H-Output-1'].setValues(frequency=1, rebar=EXCLUDE,
		region=mdb.models['Model-1'].rootAssembly.sets['sensor_all'],sectionPoints=DEFAULT, variables=('U3',))

	## Create load and BC
	# 2.5 cycles
	mdb.models['Model-1'].TabularAmplitude(data=((0.0, 0.0), (5e-09,
    0.00194897732422402), (1e-08, 0.00749936469779943), (1.5e-08,
    0.0157821751620511), (2e-08, 0.0254167565564769), (2.5e-08,
    0.0346082692225902), (3e-08, 0.0412763459590382), (3.5e-08,
    0.0432076140126375), (4e-08, 0.038223337957104), (4.5e-08,
    0.0243524776957952), (5e-08, 1.16943363265131e-17), (5.5e-08,
    -0.0358996381001867), (6e-08, -0.0837533001355521), (6.5e-08,
    -0.143212617023721), (7e-08, -0.213116831660765), (7.5e-08,
    -0.291479843409094), (8e-08, -0.375524011195478), (8.5e-08,
    -0.461760857512023), (9e-08, -0.546116346548657), (9.5e-08,
    -0.624096012021681), (1e-07, -0.690983005625053), (1.05e-07,
    -0.74206023861849), (1.1e-07, -0.772846296026448), (1.15e-07,
    -0.779333795384948), (1.2e-07, -0.758218396990101), (1.25e-07,
    -0.707106781186548), (1.3e-07, -0.624692593655586), (1.35e-07,
    -0.510890597079379), (1.4e-07, -0.366921005010254), (1.45e-07,
    -0.195338134499781), (1.5e-07, -2.40462520828615e-16), (1.55e-07,
    0.214021832507633), (1.6e-07, 0.44059003132148), (1.65e-07,
    0.672702090996347), (1.7e-07, 0.90273634016427), (1.75e-07,
    1.122733718964), (1.8e-07, 1.32470383470392), (1.85e-07, 1.5009424616851),
    (1.9e-07, 1.64434687957902), (1.95e-07, 1.74871528675894), (2e-07,
    1.80901699437495), (2.05e-07, 1.82162118825236), (2.1e-07,
    1.78447369462384), (2.15e-07, 1.69721333119772), (2.2e-07,
    1.56122197242876), (2.25e-07, 1.37960529315051), (2.3e-07,
    1.15710415002271), (2.35e-07, 0.89993957958565), (2.4e-07,
    0.615597297450343), (2.45e-07, 0.31256024239776), (2.5e-07,
    6.12323399573677e-16), (2.55e-07, -0.312560242397761), (2.6e-07,
    -0.615597297450346), (2.65e-07, -0.899939579585651), (2.7e-07,
    -1.15710415002271), (2.75e-07, -1.3796052931505), (2.8e-07,
    -1.56122197242876), (2.85e-07, -1.69721333119772), (2.9e-07,
    -1.78447369462384), (2.95e-07, -1.82162118825236), (3e-07,
    -1.80901699437495), (3.05e-07, -1.74871528675894), (3.1e-07,
    -1.64434687957902), (3.15e-07, -1.5009424616851), (3.2e-07,
    -1.32470383470392), (3.25e-07, -1.122733718964), (3.3e-07,
    -0.902736340164271), (3.35e-07, -0.672702090996346), (3.4e-07,
    -0.440590031321481), (3.45e-07, -0.214021832507635), (3.5e-07,
    -5.61079215266769e-16), (3.55e-07, 0.195338134499779), (3.6e-07,
    0.366921005010254), (3.65e-07, 0.510890597079379), (3.7e-07,
    0.624692593655586), (3.75e-07, 0.707106781186547), (3.8e-07,
    0.758218396990101), (3.85e-07, 0.779333795384948), (3.9e-07,
    0.772846296026448), (3.95e-07, 0.74206023861849), (4e-07,
    0.690983005625053), (4.05e-07, 0.624096012021681), (4.1e-07,
    0.546116346548657), (4.15e-07, 0.461760857512022), (4.2e-07,
    0.375524011195478), (4.25e-07, 0.291479843409095), (4.3e-07,
    0.213116831660765), (4.35e-07, 0.143212617023721), (4.4e-07,
    0.0837533001355522), (4.45e-07, 0.0358996381001871), (4.5e-07,
    1.05249026938618e-16), (4.55e-07, -0.0243524776957951), (4.6e-07,
    -0.0382233379571039), (4.65e-07, -0.0432076140126374), (4.7e-07,
    -0.0412763459590381), (4.75e-07, -0.0346082692225902), (4.8e-07,
    -0.0254167565564767), (4.85e-07, -0.015782175162051), (4.9e-07,
    -0.00749936469779942), (4.95e-07, -0.00194897732422402), (5e-07, 0.0)),
    name='cos_2_5', smooth=SOLVER_DEFAULT, timeSpan=STEP)

	# 3 cycles
	mdb.models['Model-1'].TabularAmplitude(data=((0.0, 0.0), (6e-09,
    0.00193831950713421), (1.2e-08, 0.00733156530200401), (1.8e-08,
    0.0149553688471836), (2.4e-08, 0.0229018899099815), (3e-08,
    0.0287682579175257), (3.6e-08, 0.0298997180897102), (4.2e-08,
    0.0236685495833722), (4.8e-08, 0.00776676782235138), (5.4e-08,
    -0.0195108844724957), (6e-08, -0.0590169943749475), (6.6e-08,
    -0.110556088450452), (7.2e-08, -0.172761898856107), (7.8e-08,
    -0.243060632353894), (8.4e-08, -0.317727779806876), (9e-08,
    -0.392039521920206), (9.6e-08, -0.460513060657597), (1.02e-07,
    -0.517223685156237), (1.08e-07, -0.556180508961424), (1.14e-07,
    -0.57173799851997), (1.2e-07, -0.559016994374947), (1.26e-07,
    -0.514307163396255), (1.32e-07, -0.435422865745577), (1.38e-07,
    -0.321986312142294), (1.44e-07, -0.175615544492801), (1.5e-07,
    -1.83697019872103e-16), (1.56e-07, 0.199147084678648), (1.62e-07,
    0.414262793227062), (1.68e-07, 0.636230724212417), (1.74e-07,
    0.854787048461122), (1.8e-07, 1.05901699437495), (1.86e-07,
    1.23791610641207), (1.92e-07, 1.38098581329584), (1.98e-07,
    1.47882977170031), (2.04e-07, 1.52371634197136), (2.1e-07,
    1.5100735106701), (2.16e-07, 1.43488558028085), (2.22e-07,
    1.29796585319769), (2.28e-07, 1.10208608064127), (2.34e-07,
    0.852951259752979), (2.4e-07, 0.559016994374945), (2.46e-07,
    0.231155582656112), (2.52e-07, -0.117814271236274), (2.58e-07,
    -0.473711224746337), (2.64e-07, -0.821658865040433), (2.7e-07,
    -1.14680224666742), (2.76e-07, -1.43503536493284), (2.82e-07,
    -1.67370048215685), (2.88e-07, -1.8522214064745), (2.94e-07,
    -1.96263618195024), (3e-07, -2.0), (3.06e-07, -1.96263618195024), (
    3.12e-07, -1.8522214064745), (3.18e-07, -1.67370048215685), (3.24e-07,
    -1.43503536493284), (3.3e-07, -1.14680224666742), (3.36e-07,
    -0.821658865040435), (3.42e-07, -0.473711224746339), (3.48e-07,
    -0.117814271236276), (3.54e-07, 0.231155582656114), (3.6e-07,
    0.559016994374947), (3.66e-07, 0.852951259752976), (3.72e-07,
    1.10208608064127), (3.78e-07, 1.29796585319769), (3.84e-07,
    1.43488558028085), (3.9e-07, 1.5100735106701), (3.96e-07,
    1.52371634197136), (4.02e-07, 1.47882977170031), (4.08e-07,
    1.38098581329584), (4.14e-07, 1.23791610641207), (4.2e-07,
    1.05901699437495), (4.26e-07, 0.854787048461122), (4.32e-07,
    0.636230724212416), (4.38e-07, 0.41426279322706), (4.44e-07,
    0.199147084678649), (4.5e-07, 5.51091059616309e-16), (4.56e-07,
    -0.1756155444928), (4.62e-07, -0.321986312142293), (4.68e-07,
    -0.435422865745577), (4.74e-07, -0.514307163396256), (4.8e-07,
    -0.559016994374948), (4.86e-07, -0.571737998519971), (4.92e-07,
    -0.556180508961424), (4.98e-07, -0.517223685156238), (5.04e-07,
    -0.460513060657597), (5.1e-07, -0.392039521920206), (5.16e-07,
    -0.317727779806875), (5.22e-07, -0.243060632353894), (5.28e-07,
    -0.172761898856108), (5.34e-07, -0.110556088450452), (5.4e-07,
    -0.0590169943749476), (5.46e-07, -0.019510884472496), (5.52e-07,
    0.00776676782235151), (5.58e-07, 0.0236685495833723), (5.64e-07,
    0.0298997180897102), (5.7e-07, 0.0287682579175258), (5.76e-07,
    0.0229018899099815), (5.82e-07, 0.0149553688471836), (5.88e-07,
    0.00733156530200412), (5.94e-07, 0.00193831950713421), (6e-07, 0.0)),
    name='cos_3', smooth=SOLVER_DEFAULT, timeSpan=STEP)

	# 2 cycles
	mdb.models['Model-1'].TabularAmplitude(data=((0.0, 0.0), (4e-09,
    0.00195771173599771), (8e-09, 0.00763756752726646), (1.2e-08,
    0.0164688977728995), (1.6e-08, 0.0275307857688423), (2e-08,
    0.0395961100811341), (2.4e-08, 0.0511907386947495), (2.8e-08,
    0.0606655199332525), (3.2e-08, 0.0662781951924082), (3.6e-08,
    0.0662819455962172), (4e-08, 0.0590169943749474), (4.4e-08,
    0.0430015302486876), (4.8e-08, 0.0170182006929525), (5.2e-08,
    -0.019807451105763), (5.6e-08, -0.0679399694381377), (6e-08,
    -0.127381362373607), (6.4e-08, -0.197635338397332), (6.8e-08,
    -0.277690267815718), (7.2e-08, -0.366022054966911), (7.6e-08,
    -0.460617377530741), (8e-08, -0.559016994374947), (8.4e-08,
    -0.658378070661947), (8.8e-08, -0.755553745691616), (9.2e-08,
    -0.847187501568444), (9.6e-08, -0.929819303786272), (1e-07, -1.0), (
    1.04e-07, -1.05441009884268), (1.08e-07, -1.08997882068882), (1.12e-07,
    -1.10399922608489), (1.16e-07, -1.09423528942578), (1.2e-07,
    -1.05901699437495), (1.24e-07, -0.997319877312082), (1.28e-07,
    -0.90882592453047), (1.32e-07, -0.793963322142275), (1.36e-07,
    -0.653923244732814), (1.4e-07, -0.490652626376287), (1.44e-07,
    -0.306822659733312), (1.48e-07, -0.105773587952863), (1.52e-07,
    0.108562838365675), (1.56e-07, 0.331761098922761), (1.6e-07,
    0.559016994374947), (1.64e-07, 0.785276637533928), (1.68e-07,
    1.00537539476559), (1.72e-07, 1.21418245956413), (1.76e-07,
    1.40674651614807), (1.8e-07, 1.57843787866876), (1.84e-07,
    1.72508257431889), (1.88e-07, 1.8430840740036), (1.92e-07, 1.92952875473),
    (1.96e-07, 1.98227169089296), (2e-07, 2.0), (2.04e-07, 1.98227169089296), (
    2.08e-07, 1.92952875473), (2.12e-07, 1.8430840740036), (2.16e-07,
    1.72508257431888), (2.2e-07, 1.57843787866876), (2.24e-07,
    1.40674651614807), (2.28e-07, 1.21418245956413), (2.32e-07,
    1.00537539476559), (2.36e-07, 0.785276637533929), (2.4e-07,
    0.559016994374945), (2.44e-07, 0.33176109892276), (2.48e-07,
    0.108562838365674), (2.52e-07, -0.105773587952863), (2.56e-07,
    -0.306822659733309), (2.6e-07, -0.490652626376287), (2.64e-07,
    -0.653923244732812), (2.68e-07, -0.793963322142273), (2.72e-07,
    -0.908825924530468), (2.76e-07, -0.997319877312083), (2.8e-07,
    -1.05901699437495), (2.84e-07, -1.09423528942578), (2.88e-07,
    -1.10399922608489), (2.92e-07, -1.08997882068882), (2.96e-07,
    -1.05441009884268), (3e-07, -1.0), (3.04e-07, -0.929819303786272), (
    3.08e-07, -0.847187501568446), (3.12e-07, -0.755553745691616), (3.16e-07,
    -0.658378070661948), (3.2e-07, -0.559016994374948), (3.24e-07,
    -0.46061737753074), (3.28e-07, -0.366022054966911), (3.32e-07,
    -0.277690267815718), (3.36e-07, -0.197635338397332), (3.4e-07,
    -0.127381362373607), (3.44e-07, -0.0679399694381382), (3.48e-07,
    -0.0198074511057631), (3.52e-07, 0.0170182006929527), (3.56e-07,
    0.0430015302486874), (3.6e-07, 0.0590169943749474), (3.64e-07,
    0.0662819455962172), (3.68e-07, 0.0662781951924081), (3.72e-07,
    0.0606655199332526), (3.76e-07, 0.0511907386947495), (3.8e-07,
    0.0395961100811341), (3.84e-07, 0.0275307857688422), (3.88e-07,
    0.0164688977728994), (3.92e-07, 0.00763756752726657), (3.96e-07,
    0.00195771173599771), (4e-07, 0.0)), name='cos_2', smooth=SOLVER_DEFAULT,
    timeSpan=STEP)
	mdb.models['Model-1'].Pressure(amplitude='cos_2_5', createStepName='Step-1',
		distributionType=UNIFORM, field='', magnitude=1000000.0, name='Load-1',
		region=mdb.models['Model-1'].rootAssembly.surfaces['exciter'])
	mdb.models['Model-1'].YsymmBC(createStepName='Step-1', localCsys=None, name=
		'BC-1', region=mdb.models['Model-1'].rootAssembly.sets['sym_plane'])
	mdb.Job(activateLoadBalancing=False, atTime=None, contactPrint=OFF, 
		description='', echoPrint=OFF, explicitPrecision=DOUBLE, historyPrint=OFF, 
		memory=90, memoryUnits=PERCENTAGE, model='Model-1', modelPrint=OFF, 
		multiprocessingMode=DEFAULT, name='Ellip_3D_'+str(current_index), nodalOutputPrecision=FULL,
		numCpus=10, numDomains=10, parallelizationMethodExplicit=DOMAIN, queue=None
		, resultsFormat=ODB, scratch='', type=ANALYSIS, userSubroutine='', 
		waitHours=0, waitMinutes=0)
	break

	mdb.jobs['Ellip_3D_'+str(current_index)].submit(consistencyChecking=OFF)
	mdb.jobs['Ellip_3D_'+str(current_index)].waitForCompletion()

	# Open ODB file after the job is finished
	Odb_path = 'Ellip_3D_'+str(current_index)+'.odb'
	odb = openOdb(Odb_path)

	# Open history steps data
	step1 = odb.steps['Step-1']

	# Use a loop to get the U3 data of all the nodes
	set_sensor = odb.rootAssembly.nodeSets['SENSOR_ALL'].nodes[0]

	try:
		region = step1.historyRegions['Node PIPE-1.'+str(set_sensor[0].label)]
	except KeyError:
		odb.close()
		failure_flag = 1
		if trial_index == max_trial:
			failed_mesh.append(current_index)
		pass
	else:
		# Test if need to add weight to each node based on its location
		'''
		node_label_and_y_coord = []

		for i in range(len(set_sensor)):
			node_label_and_y_coord.append([set_sensor[i].label, set_sensor[i].coordinates[1]])

		node_label_and_y_coord.sort(key=lambda x: x[1])

		sorted_label = [node_label_and_y_coord[i][0] for i in range(len(node_label_and_y_coord))]
		sorted_y_coord = [node_label_and_y_coord[i][1] for i in range(len(node_label_and_y_coord))]

		weights = sorted_y_coord / sorted_y_coord[0]

		time, U3_total = zip(*step1.historyRegions['Node PIPE-1.' + str(sorted_label[0])].historyOutputs['U3'].data)
		for i in range(1, len(set_sensor)):
			time, U3 = zip(*step1.historyRegions['Node PIPE-1.' + str(set_sensor[i].label)].historyOutputs['U3'].data)
			U3_total = [a + b * weights[i] for a, b in zip(U3_total, U3)]
		'''

		time, U3_total = zip(*step1.historyRegions['Node PIPE-1.' + str(set_sensor[0].label)].historyOutputs['U3'].data)
		for i in range(1,len(set_sensor)):
			time, U3 = zip(*step1.historyRegions['Node PIPE-1.' + str(set_sensor[i].label)].historyOutputs['U3'].data)
			U3_total = [a + b for a, b in zip(U3_total, U3)]

		U3_ave = [a / len(set_sensor) for a in U3_total]

		nn = len(U3_ave)
		if nn < sampling_number:
			odb.close()
			failure_flag = 1
			if trial_index == max_trial:
				failed_earlystop.append(current_index)
		else:
			for i in range(nn):
				sheet1.write_number(current_index - 1, i, U3_ave[i])

			sheet2.write_number(0, current_index - 1, current_short_axis * (crack_short_axis == True))
			sheet2.write_number(1, current_index - 1, current_long_axis * (crack_long_axis == True))
			sheet2.write_number(2, current_index - 1, current_depth * (crack_depth == True))
			sheet2.write_number(3, current_index - 1, current_angle / math.pi * 180.0 * (crack_orientation == True))
			odb.close()
			failure_flag = 0

	# Remove all the files after getting the data
	try:
		os.remove('Ellip_3D_' + str(current_index) + '.abq')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_3D_' + str(current_index) + '.mdl')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_3D_' + str(current_index) + '.pac')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_3D_' + str(current_index) + '.stt')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_3D_' + str(current_index) + '.inp')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_3D_' + str(current_index) + '.prt')
	except WindowsError:
		pass
	try:
		os.remove('Ellip_3D_' + str(current_index) + '.res')
	except WindowsError:
		pass
	if remove_odb:
		try:
			os.remove('Ellip_3D_' + str(current_index) + '.odb')
		except WindowsError:
			pass

	if not failure_flag:
		trial_index = 0
		if current_index % space_number == 0:
			loop_index = loop_index + 1
		current_index = current_index + 1
	else:
		if trial_index == max_trial:
			trial_index = 0
			failure_flag = 0
			if current_index % space_number == 0:
				loop_index = loop_index + 1
			current_index = current_index + 1

"""Close the workbooks"""
wb1.close()
wb2.close()

# Write error message
len_fail_mesh = len(failed_mesh)
len_fail_earlystop = len(failed_earlystop)
with open('ellip_crack_3D/Ellip_failed_simulation.txt', 'w') as f:
	for i in range(0, len_fail_mesh):
		f.write('%s, ' % failed_mesh[i])
	f.write('\nOut of '+str(num_of_simulation)+' simulations, '+str(len_fail_mesh)+' have failed due to mesh generation.')
	f.write('\n')
	for i in range(0, len_fail_earlystop):
		f.write('%s, ' % failed_earlystop[i])
	f.write('\nOut of '+str(num_of_simulation)+' simulations, '+str(len_fail_earlystop)+' have failed due to unexpected stop.')